////////////////////////////////////////////////////////////////////////////
// $Id: CVideoDMO.h,v 1.6 2004-08-31 16:33:39 adcockj Exp $
/////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 John Adcock.  All rights reserved.
// This software was based on sample code generated by the 
// DMO project wizard.  That code is (c) Microsoft Corporation
/////////////////////////////////////////////////////////////////////////////
//
// This file is free software; you can redistribute it and/or modify it
// under the terms of the GNU Library General Public License as published by
// the Free Software Foundation; either version 2 of the License, or (at your
// option) any later version.
//
// This software is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Library General Public License for more details
//
/////////////////////////////////////////////////////////////////////////////
// CVS Log
//
// $Log: not supported by cvs2svn $
// Revision 1.5  2004/03/15 17:17:04  adcockj
// Basic registry saving support
//
// Revision 1.4  2004/02/06 12:17:15  adcockj
// Major changes to the Libraries to remove ATL and replace with YACL
// First draft of Mpeg2 video decoder filter
// Broken DScalerFilter part converted to new library
//
// Revision 1.3  2003/10/31 17:19:37  adcockj
// Added support for manual pulldown selection (works with Elecard Filters)
//
// Revision 1.2  2003/05/21 17:06:00  adcockj
// Added new filter
//
// Revision 1.1  2003/05/20 16:52:56  adcockj
// Added new files
//
/////////////////////////////////////////////////////////////////////////////

#pragma once 

#include "params.h"
#include "CDMO.h"

#define MAX_FIELDS_IN_BUFFER 6

/////////////////////////////////////////////////////////////////////////////
// CDMO
class CVideoDMO : 
	public CDMO,
	public IDScalerVideoFilterPlugin,
    public IInterlacedBufferStack
{
public:
    CVideoDMO(LPCWSTR Name, long FieldsToBuffer, long FieldsDelay, eVideoFilterPosition Position);
	virtual ~CVideoDMO();

//IMediaObjectImpl Methods   
protected:
	STDMETHOD(InternalDiscontinuity)(DWORD dwInputStreamIndex);
    STDMETHOD(InternalFlush)(void);
	STDMETHOD(InternalFreeStreamingResources)(void);
    STDMETHOD(InternalGetInputSizeInfo)(DWORD dwInputStreamIndex, DWORD *pcbSize, DWORD *pcbMaxLookahead, DWORD *pcbAlignment);
	STDMETHOD(InternalGetOutputSizeInfo)(DWORD dwOutputStreamIndex, DWORD *pcbSize, DWORD *pcbAlignment);
    STDMETHOD(InternalGetInputStreamInfo)(DWORD dwInputStreamIndex, DWORD *pdwFlags);
    STDMETHOD(InternalGetOutputStreamInfo)(DWORD dwInputStreamIndex, DWORD *pdwFlags);
	STDMETHOD(InternalAcceptingInput)(DWORD dwInputStreamIndex);

// IDScalerVideoFilterPlugin
public:
    STDMETHOD(get_Position)(eVideoFilterPosition* pPosition);
    STDMETHOD(get_NumFieldsDelay)(DWORD* pFieldsDelay);
    STDMETHOD(get_NumFieldsBuffered)(DWORD* pFieldsBuffered);

// IInterlacedBufferStack
public:
    STDMETHOD(PushSample)(IMediaSample* InputSample);
    STDMETHOD(get_NumFields)(DWORD* Count);
    STDMETHOD(GetField)(DWORD Index, IInterlacedField** Field);
    STDMETHOD(GetStaticMap)(IMediaBuffer** StaticMap);
    STDMETHOD(GetFrameDiffMap)(IMediaBuffer** DiffMap);
    STDMETHOD(PopStack)();
    STDMETHOD(ClearAll)();

protected:
    virtual void RemoveOneFieldFromBuffer();

protected:
    class CField: public IInterlacedField
    {
    public:
		CField(){};
		~CField(){};
	    STDMETHOD(GetBufferAndLength)(BYTE** ppBuffer, DWORD* pcbLength);
	    STDMETHOD(GetMaxLength)(DWORD* pcbMaxLength);
	    STDMETHOD(SetLength)(DWORD cbLength);
        STDMETHOD(get_TopFieldFirst)(BOOLEAN* TopFieldFirst);
        STDMETHOD(get_Hint)(eDetectionHint* HintValue);
		STDMETHOD(QueryInterface)(const IID& iid, void** pInf) {*pInf = NULL; return S_OK;};
		ULONG STDMETHODCALLTYPE AddRef(void) {return 1;};
		ULONG STDMETHODCALLTYPE Release(void) {return 1;};
		void Clear()
		{
			m_IsTopLine = FALSE;
			m_StartTime = 0;
			m_Length = 0;
            m_Hint = HINT_NONE;
			m_Buffer.Detach();
		};
		const CField& operator=(const CField& RHS)
		{
			m_IsTopLine = RHS.m_IsTopLine;
			m_StartTime = RHS.m_StartTime;
			m_Length = RHS.m_Length;
			m_Buffer = RHS.m_Buffer;
			m_Hint = RHS.m_Hint;
			return *this;
		}
    public:
        BOOL m_IsTopLine;
        eDetectionHint m_Hint;
        REFERENCE_TIME m_StartTime;
        REFERENCE_TIME m_Length;
        SI(IMediaBuffer) m_Buffer;
    };

    enum eState
    {
        STATE_START,
        STATE_RUNNING,
        STATE_FINISHING
    };
    
    CField m_IncomingFields[MAX_FIELDS_IN_BUFFER];
    DWORD m_FieldsInBuffer;
    DWORD m_NumFieldsToBuffer;
    DWORD m_FieldsDelay;
    DWORD m_StartFieldsDone;

    eState m_InternalState;
    eVideoFilterPosition m_Position;
};


