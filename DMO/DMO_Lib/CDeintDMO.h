////////////////////////////////////////////////////////////////////////////
// $Id: CDeintDMO.h,v 1.1 2003-05-16 16:19:12 adcockj Exp $
/////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 John Adcock.  All rights reserved.
// This software was based on sample code generated by the 
// DMO project wizard.  That code is (c) Microsoft Corporation
/////////////////////////////////////////////////////////////////////////////
//
// This file is free software; you can redistribute it and/or modify it
// under the terms of the GNU Library General Public License as published by
// the Free Software Foundation; either version 2 of the License, or (at your
// option) any later version.
//
// This software is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Library General Public License for more details
//
/////////////////////////////////////////////////////////////////////////////
// CVS Log
//
// $Log: not supported by cvs2svn $
/////////////////////////////////////////////////////////////////////////////

#pragma once 

#include "CDMO.h"

#define MAX_FIELDS_IN_BUFFER 6

/////////////////////////////////////////////////////////////////////////////
// CInPlaceDMO
class ATL_NO_VTABLE CDeintDMO : 
    public CDMO,
    public IDeinterlace
{

public:
    CDeintDMO(long FieldsToBuffer, long FieldsDelay, long Complexity);	// Constructor
	~CDeintDMO();	// Destructor

BEGIN_COM_MAP(CDeintDMO)
	COM_INTERFACE_ENTRY(IDeinterlace)
    COM_INTERFACE_ENTRY_CHAIN(CDMO)
END_COM_MAP()


protected:
	//IMediaObjectImpl Methods   
	STDMETHOD(InternalDiscontinuity)(DWORD dwInputStreamIndex);
    STDMETHOD(InternalFlush)(void);
	STDMETHOD(InternalFreeStreamingResources)(void);
    STDMETHOD(InternalGetInputSizeInfo)(DWORD dwInputStreamIndex, DWORD *pcbSize, DWORD *pcbMaxLookahead, DWORD *pcbAlignment);
	STDMETHOD(InternalGetOutputSizeInfo)(DWORD dwOutputStreamIndex, DWORD *pcbSize, DWORD *pcbAlignment);
	STDMETHOD(InternalProcessInput)(DWORD dwInputStreamIndex, IMediaBuffer *pBuffer, DWORD dwFlags, REFERENCE_TIME rtTimestamp, REFERENCE_TIME rtTimelength);
	STDMETHOD(InternalProcessOutput)(DWORD dwFlags, DWORD cOutputBufferCount, DMO_OUTPUT_DATA_BUFFER *pOutputBuffers, DWORD *pdwStatus);
    HRESULT InternalGetInputType(DWORD dwInputStreamIndex, DWORD dwTypeIndex, DMO_MEDIA_TYPE *pmt);
	HRESULT InternalGetOutputType(DWORD dwOutputStreamIndex, DWORD dwTypeIndex, DMO_MEDIA_TYPE *pmt);
    HRESULT InternalCheckInputType(DWORD dwInputStreamIndex, const DMO_MEDIA_TYPE *pmt);
    HRESULT InternalCheckOutputType(DWORD dwInputStreamIndex, const DMO_MEDIA_TYPE *pmt);

	// IMediaObjectImpl Required overides
	STDMETHOD(InternalAcceptingInput)(DWORD dwInputStreamIndex);

    // IDeinterlace methods
    STDMETHOD(GetComplexityIndex)(long* pComplexity);
    STDMETHOD(GetNumFieldsDelay)(long* pFieldsDelay);
    STDMETHOD(GetNumFieldsBuffered)(long* pFieldsBuffered);


    STDMETHOD(InternalGetInputStreamInfo)(DWORD dwInputStreamIndex, DWORD *pdwFlags);
    STDMETHOD(InternalGetOutputStreamInfo)(DWORD dwInputStreamIndex, DWORD *pdwFlags);

	// Private functions
    /** UpdateStatesInternal
        Override this function if you need to do maintain
        any information based on the parameters
    */
    HRESULT DoProcess(BYTE *pbData, const BYTE *pbInputData, DWORD BytesToProcess);

protected:
    virtual void ProcessSingleFrame(DMO_OUTPUT_DATA_BUFFER *pOutputBuffer);
    virtual void DoDeinterlacingMethod(DMO_OUTPUT_DATA_BUFFER *pOutputBuffer) = 0;
    virtual void RemoveOneFieldFromBuffer();

protected:
    typedef struct
    {
        BYTE* pLumaStart;
        BYTE* pChromaStart;
        BOOL IsTopLine;
        REFERENCE_TIME StartTime;
        REFERENCE_TIME Length;
        CComPtr<IMediaBuffer> m_Buffer;
    } TField;

    enum eState
    {
        STATE_START,
        STATE_RUNNING,
        STATE_FINISHING
    };
    
    TField m_IncomingFields[MAX_FIELDS_IN_BUFFER];
    long m_FieldsInBuffer;
    long m_NumFieldsToBuffer;
    long m_ComplexityIndex;
    long m_FieldsDelay;
    long m_StartFieldsDone;

    eState m_InternalState;
};
