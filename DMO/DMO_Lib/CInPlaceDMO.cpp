////////////////////////////////////////////////////////////////////////////
// $Id: CInPlaceDMO.cpp,v 1.1 2003-05-16 16:19:12 adcockj Exp $
/////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 John Adcock.  All rights reserved.
// This software was based on sample code generated by the 
// DMO project wizard.  That code is (c) Microsoft Corporation
/////////////////////////////////////////////////////////////////////////////
//
// This file is free software; you can redistribute it and/or modify it
// under the terms of the GNU Library General Public License as published by
// the Free Software Foundation; either version 2 of the License, or (at your
// option) any later version.
//
// This software is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Library General Public License for more details
//
/////////////////////////////////////////////////////////////////////////////
// CVS Log
//
// $Log: not supported by cvs2svn $
/////////////////////////////////////////////////////////////////////////////


#include "stdafx.h"
#include "param.h"
#include "CInPlaceDMO.h"


/////////////////////////////////////////////////////////////////////////////
// CInPlaceDMO

///////////////////////
//
// CInPlaceDMO::CInPlaceDMO
//
//  Constructor for CInPlaceDMO.
//
CInPlaceDMO::CInPlaceDMO()
{
}


///////////////////////
//
// CInPlaceDMO::~CInPlaceDMO
//
//  Destructor for CInPlaceDMO.
//
CInPlaceDMO::~CInPlaceDMO()
{
}

///////////////////////////////
//
// IMediaObjectInPlace Methods
//

///////////////////////
//
// IMediaObjectInPlace::Process
//
//  The Process method processes a block of data. The application supplies a
//  pointer to a block of input data. The DMO processes the data in place.
//
//  Parameters
//
//      ulSize
//          [in] Size of the data, in bytes.
//
//      pData
//          [in, out] Pointer to a buffer of size ulSize. On input, the buffer
//          holds the input data. If the method returns successfully, the
//          buffer contains the output data.
//
//      refTimeStart
//          [in] Start time of the data.
//
//      dwFlags
//          [in] Either DMO_INPLACE_NORMAL or DMO_INPLACE_ZERO. See Remarks
//          for more information.
//
//  Return Value
//      S_FALSE Success. There is still data to process.
//      S_TRUE Success. There is no remaining data to process.
//      E_FAIL Failure.
//
//  If the method fails, the buffer might contain garbage. The application
//  should not use the contents of the buffer.
//
//  The DMO might produce output data beyond the length of the input data. This
//  is called an effect tail. For example, a reverb effect continues after the
//  input reaches silence. If the DMO has an effect tail, this method returns
//  S_FALSE.
//
//  While the application has input data for processing, call the Process
//  method with the dwFlags parameter set to DMO_INPLACE_NORMAL. If the last
//  such call returns S_FALSE, call Process again, this time with a zeroed input
//  buffer and the DMO_INPLACE_ZERO flag. The DMO will now fill the zeroed buffer
//  with the effect tail. Continue calling Process in this way until the return
//  value is S_TRUE, indicating that the DMO has finished processing the effect
//  tail.
//
//  If the DMO has no effect tail, this method always returns S_TRUE (or an error code).
//
HRESULT CInPlaceDMO::Process(ULONG ulSize, BYTE *pData, REFERENCE_TIME refTimeStart, DWORD dwFlags)
{

// TODO: Modify implementation of Process() if necessary

    HRESULT hr = S_OK;

	if (!m_fInitialized)
	{
		hr = AllocateStreamingResources();
	}

    if (SUCCEEDED(hr))
    {

	    // Update parameter values from any curves that may be in effect.
	    // We pick up the current values stored in the CParamsManager helper for time rtStart.

	    // Note that we are using IMediaParams in a less than
	    // perfect way. We update at the beginning of every time slice instead of smoothly over the curve.
	    // This is okay for an effect like gargle as long as the time slice is consistently small (which
	    // it conveniently is when hosted in DirectSound).

	    // Here are some suggestions of how it can be done, with increasing degree of accuracy. Different
	    // types of effects and effect parameters require different levels of accuracy, so no solution is the best
	    // solution for all (especially if you are concerned about CPU cost.)
	    // 1) Break the time slice up into mini pieces of some number of milliseconds
	    // each and run through all the steps in Process for each sub slice. This guarantees the
	    // stair stepping is small enough not to be noticable. This approach will work well for parameters
	    // that don't create an audible stair stepping noise (or "zipper") noise when controled in this way.
	    // Control over volume, for example, does not work well.
	    // 2) Use the above mechanism, but pass the start and end values for each parameter to the
	    // processing engine. It, in turn, applies linear interpolation to each parameter. This results
	    // in a smooth approximation of the parameter curve and removes all but the most subtle aliasing noise.
	    // 3) Pass the curves directly to the processing engine, which accurately calculates each sample
	    // mathematically. This is obviously the best, but most complex and CPU intensive.
	    this->UpdateActiveParams(refTimeStart, *this);

        // Process the data
	    hr = DoProcess(pData);
    }
	return hr;
}

