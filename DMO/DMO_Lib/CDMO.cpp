////////////////////////////////////////////////////////////////////////////
// $Id: CDMO.cpp,v 1.1 2003-05-16 16:19:12 adcockj Exp $
/////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 John Adcock.  All rights reserved.
// This software was based on sample code generated by the 
// DMO project wizard.  That code is (c) Microsoft Corporation
/////////////////////////////////////////////////////////////////////////////
//
// This file is free software; you can redistribute it and/or modify it
// under the terms of the GNU Library General Public License as published by
// the Free Software Foundation; either version 2 of the License, or (at your
// option) any later version.
//
// This software is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Library General Public License for more details
//
/////////////////////////////////////////////////////////////////////////////
// CVS Log
//
// $Log: not supported by cvs2svn $
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "param.h"
#include "CDMO.h"
#include "DMO_Lib.h"
#include "..\..\GenDMOProp\GenDMOProp_i.c"


/////////////////////////////////////////////////////////////////////////////
// CDMO
CDMO::CDMO()
{
	m_fDirty = TRUE;
	m_fInitialized = FALSE;
    m_ParentFilter = NULL;
};

CDMO::~CDMO()
{
	// Free streaming resources in case it hasn't been done by the client
	InternalFreeStreamingResources();
};


HRESULT CDMO::UpdateStatesInternal()
{
	return S_OK;
}


////////////////////////////////
//
// IMediaObjectImpl Methods
//
////////////////////////////////

//
// IMediaObjectImpl::InternalDiscontinuity
//
//  *** Called by Discontinuity, description below ***
//
// The Discontinuity method signals a discontinuity on the specified input
// stream.
//
// Possible Return Values:
//  S_OK                        Success
//  DMO_E_INVALIDSTREAMINDEX    Invalid streamindex
//
// A discontinuity represents a break in the input. A discontinuity might
// occur because no more data is expected, the format is changing, or there
// is a gap in the data. After a discontinuity, the DMO does not accept further
// input on that stream until all pending data has been processed. The
// application should call the ProcessOutput method until none of the streams
// returns the DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE flag.
//
HRESULT CDMO::InternalDiscontinuity(DWORD dwInputStreamIndex)
{
    if(dwInputStreamIndex != 0)
    {
        return DMO_E_INVALIDSTREAMINDEX;
    }
	return S_OK;
}

///////////////////////////////
//
//  IMediaObjectImpl::InternalAllocateStreamingResources
//
//  *** Called by AllocateStreamingResources, description below ***
//
//  The AllocateStreamingResources method allocates any resources needed by
//  the DMO. Calling this method is always optional.
//
//  An application can call this method as a streaming optimization. It gives
//  the DMO an opportunity to perform any time-consuming initializations
//  before streaming begins. If you call this method, do so after you set
//  the media types on the DMO, but before you make the first calls to
//  ProcessInput or ProcessOutput.
//
//  This method is optional in the following sense:
//
//  *  If the DMO does not support this method, the method returns S_OK.
//
//  *  If the application never calls this method, the DMO allocates resources
//     within a call to ProcessInput or ProcessOutput or Process.
//
//  If the DMO supports this method, it should also support the
//  FreeStreamingResources method.
//
//  Note:
//
//  The template keeps a private flag that indicates whether this method has
//  been called. If the method is called when the flag is already TRUE, it
//  returns S_OK without calling the InternalAllocateStreamingResources
//  method. The FreeStreamingResources method resets the flag to FALSE.
//
HRESULT CDMO::InternalAllocateStreamingResources(void)
{
	HRESULT hr = S_OK;

	if( SUCCEEDED(hr) )
	{
		hr = UpdateStatesInternal();
		m_fInitialized = TRUE;
	}

	return hr;
}

////////////////////
//
// IMediaObjectImpl::InternalFreeStreamingResources
//
//  *** Called by FreeStreamingResources, description below ***
//
// The FreeStreamingResources method frees resources allocated by the DMO.
// Calling this method is always optional.
//
// Return Value
//
// Returns S_OK if successful. Otherwise, returns an HRESULT value indicating
// the cause of the error.
//
// This method releases any resources that the AllocateStreamingResources
// method initializes.
//
// If the DMO does not support this method, the method returns S_OK. If you
// call this method during streaming, the method fails and the DMO does not
// release any resources.
//
// Regardless of whether the method fails or succeeds, the application can
// continue to call other methods on the DMO. The DMO might need to
// re-initialize resources that were previously freed.
//
HRESULT CDMO::InternalFreeStreamingResources(void)
{
	return S_OK;
}


////////////////////////////////////////
//
//  IMediaObjectImpl::InternalGetInputMaxLatency
//
//  *** Called by GetInputMaxLatency, description below ***
//
//  The GetInputMaxLatency method retrieves the maximum latency on a specified
//   input stream.
//
//  Parameters
//   dwInputStreamIndex:    Zero-based index of an input stream on the DMO.
//   prtMaxLatency:         [out] Pointer to a variable that receives the maximum latency.
//
// Return Value
// Returns an HRESULT value. The following are possible return values.
//  S_OK                        Success
//  DMO_E_INVALIDSTREAMINDEX    Invalid stream index
//  E_FAIL                      Failure
//  E_NOTIMPL                   Not implemented. Assume zero latency
//
// The latency is the difference between a time stamp on the input stream and
// the corresponding time stamp on the output stream. The maximum latency is
// the largest possible difference in the time stamps. For a DMO, determine the
// maximum latency as follows:
//
// *  Process input buffers until the DMO can produce output.
//
// *  Process as many output buffers as possible.
//
// *  The maximum latency is the largest delta between input time stamps and
//    output time stamps (taken as an absolute value).
//
//    Under this definition, latency does not include the time that it takes
//    to process samples. Nor does it include any latency introduced by the
//    size of the input buffer.
//
// For the special case where a DMO processes exactly one sample at a time,
// the maximum latency is simply the difference in time stamps.
//
// Latency is defined only when samples have time stamps, and the time stamps
// increase or decrease monotonically. Maximum latency might depend on the
// media types for the input and output streams.
//

HRESULT CDMO::InternalGetInputMaxLatency(DWORD dwInputStreamIndex, REFERENCE_TIME *prtMaxLatency)
{

// TODO: Provide a good max latency if this DMO is going to be used with DirectShow.
//		 For now, 30 is used as the default max latency.

	*prtMaxLatency = 30;

	return S_OK;
}


/////////////////////////////////////////
//
//  IMediaObjectImpl::InternalSetInputMaxLatency
//
//  *** Called by SetInputMaxLatency, description below ***
//
//  The SetInputMaxLatency method sets the maximum latency on a specified input
//  stream. For the definition of maximum latency, see GetInputMaxLatency.
//
//  Parameters
//
//      dwInputStreamIndex
//          Zero-based index of an input stream on the DMO.
//
//      rtMaxLatency
//          Maximum latency.
//
//  Return Value
//      S_OK Success
//      DMO_E_INVALIDSTREAMINDEX Invalid stream index
//      E_FAIL Failure
//      E_NOTIMPL Not implemented
//
HRESULT CDMO::InternalSetInputMaxLatency(DWORD dwInputStreamIndex, REFERENCE_TIME rtMaxLatency)
{
	// Method not implemented
	return E_NOTIMPL;
}


////////////////////////////////////
//
//  IMediaObjectImpl::InternalGetInputSizeInfo
//
//  *** Called by GetInputSizeInfo, description below ***
//
//  The GetInputSizeInfo method retrieves the buffer requirements for a
//  specified input stream.
//
//  Parameters
//
//  dwInputStreamIndex:     Zero-based index of an input stream on the DMO.
//
//  pcbSize:                [out] Pointer to a variable that receives
//      the minimum size of an input buffer for this stream, in bytes.
//
//  pulSizeMaxLookahead:        [out] Pointer to a variable that receives the
//      maximum amount of data that the DMO will hold for lookahead, in bytes.
//      If the DMO does not perform lookahead on the stream, the value is zero.
//
//  pulSizeAlignment            [out] Pointer to a variable that receives the
//      required buffer alignment, in bytes. If the input stream has no
//      alignment requirement, the value is 1.
//
//  Return Value
//      S_OK Success
//      DMO_E_INVALIDSTREAMINDEX Invalid stream index
//      DMO_E_TYPE_NOT_SET Media type was not set
//
//  The buffer requirements may depend on the media types of the various
//  streams. Before calling this method, set the media type of each stream
//  by calling the SetInputType and SetOutputType methods. If the media types
//  have not been set, this method might return an error.
//
//  If the DMO performs lookahead on the input stream, it returns the
//  DMO_INPUT_STREAMF_HOLDS_BUFFERS flag in the GetInputStreamInfo method.
//  During processing, the DMO holds up to the number of bytes indicated by the
//  pulSizeMaxLookahead parameter. The application must allocate enough buffers for
//  the DMO to hold this much data.
//
//  A buffer is aligned if the buffer's start address is a multiple of
//  *pulSizeAlignment. The alignment must be a power of two. Depending on the
//  microprocessor, reads and writes to an aligned buffer might be faster than
//  to an unaligned buffer. Also, some microprocessors do not support unaligned
//  reads and writes.
//
//  Note:
//
//  GetInputSizeInfo returns DMO_E_TYPE_NOT_SET unless all of the non-optional
//  streams have media types. Therefore, in the derived class, the internal
//  methods can assume that all of the non-optional streams have media types.
//
HRESULT CDMO::InternalGetInputSizeInfo(DWORD dwInputStreamIndex, DWORD *pcbSize, DWORD *pulSizeMaxLookahead, DWORD *pulSizeAlignment)
{
	// We don't have to do any validation, because it is all done in the base class

	HRESULT hr = S_OK;
	const DMO_MEDIA_TYPE* pmt;
	pmt = InputType(0);
    if(pmt->majortype == MEDIATYPE_Video)
    {
        // not yet implemented
        hr = E_FAIL;
    }
    else if(pmt->majortype == MEDIATYPE_Audio)
    {
	    const WAVEFORMATEX* pwfx = reinterpret_cast<const WAVEFORMATEX*>(pmt->pbFormat);
	    *pcbSize = pwfx->nChannels * pwfx->wBitsPerSample / 8;
	    *pulSizeMaxLookahead = 0;	// no look ahead
	    *pulSizeAlignment = 1;		// no alignment requirement
    }
    else
    {
        // not yet implemented
        hr = E_FAIL;
    }

	return hr;
}


//////////////////////////////////////
//
//  IMediaObjectImpl::InternalGetOutputSizeInfo
//
//  *** Called by GetOutputSizeInfo, description below ***
//
//  The GetOutputSizeInfo method retrieves the buffer requirements for a
//  specified output stream.
//
//  Parameters
//
//      dwOutputStreamIndex
//          Zero-based index of an output stream on the DMO.
//
//      pcbSize
//          [out] Pointer to a variable that receives the minimum size of an
//          output buffer for this stream, in bytes.
//
//      pulSizeAlignment
//          [out] Pointer to a variable that receives the required buffer
//          alignment, in bytes. If the output stream has no alignment
//          requirement, the value is 1.
//
//  Return Value
//      S_OK Success
//      DMO_E_INVALIDSTREAMINDEX Invalid stream index
//      DMO_E_TYPE_NOT_SET Media type was not set
//
//  The buffer requirements may depend on the media types set for each of the
//  streams.
//
//  Before calling this method, set the media type of each stream by calling
//  the SetInputType and SetOutputType methods. If the media types have not
//  been set, this method might return an error. However, if a stream is
//  optional, and the application will not use the stream, you do not have to
//  set the media type for the stream.
//
//  A buffer is aligned if the buffer's start address is a multiple of
//  *pulSizeAlignment. Depending on the architecture of the microprocessor, it is
//  faster to read and write to an aligned buffer than to an unaligned buffer.
//  On some microprocessors, reading and writing to an unaligned buffer is not
//  supported and can cause the program to crash. Zero is not a valid alignment.
//
//  Note:
//
//  GetOutputSizeInfo returns DMO_E_TYPE_NOT_SET unless all of the non-optional
//  streams have media types. Therefore, in the derived class, the internal
//  methods can assume that all of the non-optional streams have media types.
//
HRESULT CDMO::InternalGetOutputSizeInfo(DWORD dwOutputStreamIndex, DWORD *pcbSize, DWORD *pulSizeAlignment)
{
    // We don't have to do any validation, because it is all done in the base class
	HRESULT hr = S_OK;
	const DMO_MEDIA_TYPE* pmt;
	pmt = OutputType(0);
    if(pmt->majortype == MEDIATYPE_Video)
    {
        // not yet implemented
        hr = E_FAIL;
    }
    else if(pmt->majortype == MEDIATYPE_Audio)
    {
	    const WAVEFORMATEX* pwfx = reinterpret_cast<const WAVEFORMATEX*>(pmt->pbFormat);
	    *pcbSize = pwfx->nChannels * pwfx->wBitsPerSample / 8;
	    *pulSizeAlignment = 1;
    }
    else
    {
        // not yet implemented
        hr = E_FAIL;
    }

    return hr;
}


////////////////////////////////////////
//
//  IMediaObjectImpl::InternalGetInputStreamInfo
//
//  *** Called by GetInputStreamInfo, description below ***
//
//  The GetInputStreamInfo method retrieves information about an input stream,
//  such as any restrictions on the number of samples per buffer, and whether
//  the stream performs lookahead on the input data. This information never
//  changes.
//
//  Parameters
//      dwInputStreamIndex:
//          Zero-based index of an input stream on the DMO.
//
//      pdwFlags:
//          [out] Pointer to a variable that receives a bitwise combination of
//          zero or more DMO_INPUT_STREAM_INFO_FLAGS flags.
//
//  Return Value
//      S_OK Success
//      DMO_E_INVALIDSTREAMINDEX Invalid stream index
//      E_POINTER NULL pointer argument
//
//  The DMO_INPUT_STREAMF_HOLDS_BUFFERS flag indicates that the DMO performs
//  lookahead on the incoming data.
//
//  The application must be sure to allocate sufficient buffers for the DMO
//  to process the input. Call the GetInputSizeInfo method to determine the
//  buffer requirements.
//
HRESULT CDMO::InternalGetInputStreamInfo(DWORD dwInputStreamIndex, DWORD *pdwFlags)
{
	*pdwFlags = DMO_INPUT_STREAMF_WHOLE_SAMPLES;
	*pdwFlags |= DMO_INPUT_STREAMF_FIXED_SAMPLE_SIZE;

    return S_OK;
}


//////////////////////////////////////////
//
//  IMediaObjectImpl::InternalGetOutputStreamInfo
//
//  *** Called by GetOutputStreamInfo, description below ***
//
//  The GetOutputStreamInfo method retrieves information about an output
//  stream; for example, whether the stream is discardable, and whether
//  it uses a fixed sample size. This information never changes.
//
//  Parameters
//      dwOutputStreamIndex
//          Zero-based index of an output stream on the DMO.
//
//      pdwFlags
//          [out] Pointer to a variable that receives a bitwise combination
//          of zero or more DMO_OUTPUT_STREAM_INFO_FLAGS flags.
//
//  Return Value
//
//      S_OK Success
//      DMO_E_INVALIDSTREAMINDEX Invalid stream index
//      E_POINTER NULL pointer argument
//
HRESULT CDMO::InternalGetOutputStreamInfo(DWORD dwOutputStreamIndex, DWORD *pdwFlags)
{
	*pdwFlags = DMO_OUTPUT_STREAMF_WHOLE_SAMPLES;
	*pdwFlags |= DMO_OUTPUT_STREAMF_FIXED_SAMPLE_SIZE;

	return S_OK;
}

///////////////
//
//  IMediaObjectImpl::Lock
//
// Locks the object. The derived class must declare and implement this method.
//
// If you implement your derived class using the Active Template Library (ATL),
// you can use ATL's default implementation of this method.
//
void CDMO::Lock(void)
{
	CComObjectRootEx<CComMultiThreadModel>::Lock();
}


///////////////
//
// IMediaObjectImpl::Unlock
//
// Unlocks the object. The derived class must declare and implement this method.
//
// If you implement your derived class using the Active Template Library (ATL),
// you can use ATL's default implementation of this method.
//
void CDMO::Unlock(void)
{
	CComObjectRootEx<CComMultiThreadModel>::Unlock();
}


////////////////
//
// IPersistStream::IsDirty
//
// Checks the object for changes since it was last saved
//
HRESULT CDMO::IsDirty()
{
	return m_fDirty ? S_OK : S_FALSE;
}

////////////////
//
// IPersistStream::Load
//
// Initializes an object from the stream where it was previously saved
//
HRESULT CDMO::Load(IStream *pStm)
{
	ULONG ulSizeRead = 0;
	HRESULT hr = S_OK;

	if (NULL == pStm)
	{
		return E_POINTER;
	}

	DWORD NumParams;
	hr = pStm->Read((void *)&NumParams, sizeof(NumParams), &ulSizeRead);
	if (hr != S_OK || ulSizeRead < sizeof(NumParams))
	{
		return E_FAIL;
	}

    for(int i(0); i < NumParams && i < m_cParams; ++i)
    {
        MP_DATA Param;
	    hr = pStm->Read((void *)&Param, sizeof(Param), &ulSizeRead);
	    if (hr != S_OK || ulSizeRead < sizeof(Param))
	    {
		    return E_FAIL;
	    }
        SetParam(i, Param);
    }

	m_fDirty = FALSE;

	return hr;
}


////////////////
//
// IPersistStream::Save
//
// This method saves an object to the specified stream
//
HRESULT CDMO::Save(IStream *pStm, BOOL fClearDirty)
{
	HRESULT hr = S_OK;
	ULONG ulSizeWritten = 0;

	if (NULL == pStm)
	{
		return E_POINTER;
	}

	hr = pStm->Write((void *)&m_cParams, sizeof(m_cParams), &ulSizeWritten);
	if (hr != S_OK || ulSizeWritten < sizeof(m_cParams))
	{
		return E_FAIL;
	}

    for(int i(0); i < m_cParams; ++i)
    {
        MP_DATA Param;
        GetParam(i, &Param);
	    hr = pStm->Write((void *)&Param, sizeof(Param), &ulSizeWritten);
	    if (hr != S_OK || ulSizeWritten < sizeof(Param))
	    {
		    return E_FAIL;
	    }
    }

	if (fClearDirty)
	{
		m_fDirty = FALSE;
	}

	return S_OK;
}


////////////////
//
// IPersistStream::GetSizeMax
//
// This method returns the size in bytes of the stream needed to save the object
//
HRESULT CDMO::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
	if ( NULL == pcbSize )
		return E_POINTER;

	pcbSize->QuadPart = sizeof(m_cParams) + m_cParams * sizeof(MP_DATA);
	return S_OK;
}

STDMETHODIMP CDMO::Attach(IUnknown* pFilter)
{
    if(m_ParentFilter != NULL)
    {
        return E_UNEXPECTED;
    }
    if(pFilter == NULL)
    {
        return E_POINTER;
    }
    m_ParentFilter = pFilter;
    m_ParentFilter->AddRef();
    return S_OK;
}

STDMETHODIMP CDMO::Detach()
{
    if(m_ParentFilter == NULL)
    {
        return E_UNEXPECTED;
    }
    m_ParentFilter->Release();
    m_ParentFilter = NULL;
    return S_OK;
}


