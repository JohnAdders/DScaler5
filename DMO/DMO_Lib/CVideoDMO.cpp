////////////////////////////////////////////////////////////////////////////
// $Id$
/////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 John Adcock.  All rights reserved.
// This software was based on sample code generated by the
// DMO project wizard.  That code is (c) Microsoft Corporation
/////////////////////////////////////////////////////////////////////////////
//
// This file is free software; you can redistribute it and/or modify it
// under the terms of the GNU Library General Public License as published by
// the Free Software Foundation; either version 2 of the License, or (at your
// option) any later version.
//
// This software is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Library General Public License for more details
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "params.h"
#include "CVideoDMO.h"
#include <uuids.h>


CVideoDMO::CVideoDMO(LPCWSTR Name, long FieldsToBuffer, long FieldsDelay, eVideoFilterPosition Position) :
    CDMO(Name),
    m_NumFieldsToBuffer(FieldsToBuffer),
    m_FieldsDelay(FieldsDelay),
    m_Position(Position)
{
}

CVideoDMO::~CVideoDMO()
{
}

STDMETHODIMP CVideoDMO::get_Position(eVideoFilterPosition* pPosition)
{
    if(pPosition == NULL)
    {
        return E_POINTER;
    }
    *pPosition = m_Position;
    return S_OK;
}

STDMETHODIMP CVideoDMO::get_NumFieldsDelay(DWORD* pFieldsDelay)
{
    if(pFieldsDelay == NULL)
    {
        return E_POINTER;
    }
    *pFieldsDelay = m_FieldsDelay;
    return S_OK;
}

STDMETHODIMP CVideoDMO::get_NumFieldsBuffered(DWORD* pFieldsBuffered)
{
    if(pFieldsBuffered == NULL)
    {
        return E_POINTER;
    }
    *pFieldsBuffered = m_NumFieldsToBuffer;
    return S_OK;
}

////////////////////////////////
//
// IMediaObjectImpl::InternalDiscontinuity
//
//  *** Called by Discontinuity, description below ***
//
// The Discontinuity method signals a discontinuity on the specified input
// stream.
//
// Possible Return Values:
//  S_OK                        Success
//  DMO_E_INVALIDSTREAMINDEX    Invalid streamindex
//
// A discontinuity represents a break in the input. A discontinuity might
// occur because no more data is expected, the format is changing, or there
// is a gap in the data. After a discontinuity, the DMO does not accept further
// input on that stream until all pending data has been processed. The
// application should call the ProcessOutput method until none of the streams
// returns the DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE flag.
//
HRESULT CVideoDMO::InternalDiscontinuity(DWORD dwInputStreamIndex)
{
    if(dwInputStreamIndex != 0)
    {
        return DMO_E_INVALIDSTREAMINDEX;
    }
    // move to finishing state if we have any buffers stored
    // otherwise we can happily accept new stuff
    if(m_FieldsInBuffer > 0)
    {
        m_InternalState = STATE_FINISHING;
    }
    else
    {
        if(m_NumFieldsToBuffer > 1)
        {
            m_InternalState = STATE_START;
        }
        else
        {
            m_InternalState = STATE_RUNNING;
        }
    }

    return S_OK;
}

/////////////////////////
//
//  IMediaObjectImpl::InternalFlush
//
//  *** Called by Flush, description below ***
//
//  The Flush method flushes all internally buffered data.
//
// Return Value:
// Returns S_OK if successful. Otherwise, returns an HRESULT value indicating
// the cause of the error.
//
//  The DMO performs the following actions when this method is called:
//  *  Releases any IMediaBuffer references it holds.
//
//  *  Discards any values that specify the time stamp or sample length for a
//     media buffer.
//
//  *  Reinitializes any internal states that depend on the contents of a
//     media sample.
//
//  Media types, maximum latency, and locked state do not change.
//
//  When the method returns, every input stream accepts data. Output streams
//  cannot produce any data until the application calls the ProcessInput method
//  on at least one input stream.
//
//  Note:
//
//  The template keeps a private flag that indicates the object's flushed
//  state. The Flush method sets the flag to TRUE, and the ProcessInput method
//  resets it to FALSE. If Flush is called when the flag is already TRUE, the
//  method returns S_OK without calling the InternalFlush method.
//
STDMETHODIMP CVideoDMO::InternalFlush(void)
{
    // Just clear out the buffers
    for(DWORD i(0); i < m_FieldsInBuffer; ++i)
    {
        m_IncomingFields[i].Clear();
    }

    m_FieldsInBuffer = 0;
    if(m_NumFieldsToBuffer > 1)
    {
        m_InternalState = STATE_START;
    }
    else
    {
        m_InternalState = STATE_RUNNING;
    }
    m_StartFieldsDone = 0;
    return S_OK;
}

////////////////////////////////////
//
//  IMediaObjectImpl::InternalGetInputSizeInfo
//
//  *** Called by GetInputSizeInfo, description below ***
//
//  The GetInputSizeInfo method retrieves the buffer requirements for a
//  specified input stream.
//
//  Parameters
//
//  dwInputStreamIndex:     Zero-based index of an input stream on the DMO.
//
//  pcbSize:                [out] Pointer to a variable that receives
//      the minimum size of an input buffer for this stream, in bytes.
//
//  pulSizeMaxLookahead:        [out] Pointer to a variable that receives the
//      maximum amount of data that the DMO will hold for lookahead, in bytes.
//      If the DMO does not perform lookahead on the stream, the value is zero.
//
//  pulSizeAlignment            [out] Pointer to a variable that receives the
//      required buffer alignment, in bytes. If the input stream has no
//      alignment requirement, the value is 1.
//
//  Return Value
//      S_OK Success
//      DMO_E_INVALIDSTREAMINDEX Invalid stream index
//      DMO_E_TYPE_NOT_SET Media type was not set
//
//  The buffer requirements may depend on the media types of the various
//  streams. Before calling this method, set the media type of each stream
//  by calling the SetInputType and SetOutputType methods. If the media types
//  have not been set, this method might return an error.
//
//  If the DMO performs lookahead on the input stream, it returns the
//  DMO_INPUT_STREAMF_HOLDS_BUFFERS flag in the GetInputStreamInfo method.
//  During processing, the DMO holds up to the number of bytes indicated by the
//  pulSizeMaxLookahead parameter. The application must allocate enough buffers for
//  the DMO to hold this much data.
//
//  A buffer is aligned if the buffer's start address is a multiple of
//  *pulSizeAlignment. The alignment must be a power of two. Depending on the
//  microprocessor, reads and writes to an aligned buffer might be faster than
//  to an unaligned buffer. Also, some microprocessors do not support unaligned
//  reads and writes.
//
//  Note:
//
//  GetInputSizeInfo returns DMO_E_TYPE_NOT_SET unless all of the non-optional
//  streams have media types. Therefore, in the derived class, the internal
//  methods can assume that all of the non-optional streams have media types.
//
STDMETHODIMP CVideoDMO::InternalGetInputSizeInfo(DWORD dwInputStreamIndex, DWORD *pcbSize, DWORD *pulSizeMaxLookahead, DWORD *pulSizeAlignment)
{
    // We don't have to do any validation, because it is all done in the base class

    HRESULT hr = S_OK;
    const DMO_MEDIA_TYPE* pmt;
    pmt = InputType(0);

    if(pmt->majortype == MEDIATYPE_Video &&
        pmt->formattype == FORMAT_VIDEOINFO2)
    {
        *pcbSize = pmt->lSampleSize;
        // work out a sensible look ahead amount
        // this is the number of frames we need ahead
        VIDEOINFOHEADER2* Format = (VIDEOINFOHEADER2*)pmt->pbFormat;
        if(Format->dwInterlaceFlags & AMINTERLACE_IsInterlaced)
        {
            *pulSizeMaxLookahead = pmt->lSampleSize * (m_FieldsDelay * 2 + 1) / 2;
            *pulSizeAlignment = 1;        // no alignment requirement
        }
        else
        {
            *pulSizeMaxLookahead = pmt->lSampleSize * m_FieldsDelay;
        }
    }
    else
    {
        // what's going on
        hr = E_FAIL;
    }

    return hr;
}


//////////////////////////////////////
//
//  IMediaObjectImpl::InternalGetOutputSizeInfo
//
//  *** Called by GetOutputSizeInfo, description below ***
//
//  The GetOutputSizeInfo method retrieves the buffer requirements for a
//  specified output stream.
//
//  Parameters
//
//      dwOutputStreamIndex
//          Zero-based index of an output stream on the DMO.
//
//      pcbSize
//          [out] Pointer to a variable that receives the minimum size of an
//          output buffer for this stream, in bytes.
//
//      pulSizeAlignment
//          [out] Pointer to a variable that receives the required buffer
//          alignment, in bytes. If the output stream has no alignment
//          requirement, the value is 1.
//
//  Return Value
//      S_OK Success
//      DMO_E_INVALIDSTREAMINDEX Invalid stream index
//      DMO_E_TYPE_NOT_SET Media type was not set
//
//  The buffer requirements may depend on the media types set for each of the
//  streams.
//
//  Before calling this method, set the media type of each stream by calling
//  the SetInputType and SetOutputType methods. If the media types have not
//  been set, this method might return an error. However, if a stream is
//  optional, and the application will not use the stream, you do not have to
//  set the media type for the stream.
//
//  A buffer is aligned if the buffer's start address is a multiple of
//  *pulSizeAlignment. Depending on the architecture of the microprocessor, it is
//  faster to read and write to an aligned buffer than to an unaligned buffer.
//  On some microprocessors, reading and writing to an unaligned buffer is not
//  supported and can cause the program to crash. Zero is not a valid alignment.
//
//  Note:
//
//  GetOutputSizeInfo returns DMO_E_TYPE_NOT_SET unless all of the non-optional
//  streams have media types. Therefore, in the derived class, the internal
//  methods can assume that all of the non-optional streams have media types.
//
STDMETHODIMP CVideoDMO::InternalGetOutputSizeInfo(DWORD dwOutputStreamIndex, DWORD *pcbSize, DWORD *pulSizeAlignment)
{
    // We don't have to do any validation, because it is all done in the base class
    HRESULT hr = S_OK;
    const DMO_MEDIA_TYPE* pmt;
    pmt = OutputType(0);

    if(pmt->majortype == MEDIATYPE_Video)
    {
        *pcbSize = pmt->lSampleSize;
        *pulSizeAlignment = 1;
    }
    else
    {
        // what's going on
        hr = E_FAIL;
    }

    return hr;
}

////////////////////////////////////////
//
//  IMediaObjectImpl::InternalAcceptingInput
//
//  Queries whether an input stream can accept more input. The derived class
//  must declare and implement this method.
//
//  Parameters
//
//      dwInputStreamIndex
//          Index of an input stream.
//
//  Return Value
//
//      Returns S_OK if the input stream can accept input, or S_FALSE otherwise.
//
//  Note:
//
//  Called by IMediaObject::GetInputStatus
//
STDMETHODIMP CVideoDMO::InternalAcceptingInput(DWORD dwInputStreamIndex)
{
    switch(m_InternalState)
    {
    case STATE_START:
    case STATE_RUNNING:
        if(m_FieldsInBuffer >= m_NumFieldsToBuffer)
        {
            return S_FALSE;
        }
        break;
    case STATE_FINISHING:
        // If we've still got data to process so tell
        // caller to go away
        if(m_FieldsInBuffer > 0)
        {
            return S_FALSE;
        }
        break;
    }

    return S_OK;
}

STDMETHODIMP CVideoDMO::InternalFreeStreamingResources(void)
{
    return S_OK;
}
////////////////////////////////////////
//
//  IMediaObjectImpl::InternalGetInputStreamInfo
//
//  *** Called by GetInputStreamInfo, description below ***
//
//  The GetInputStreamInfo method retrieves information about an input stream,
//  such as any restrictions on the number of samples per buffer, and whether
//  the stream performs lookahead on the input data. This information never
//  changes.
//
//  Parameters
//      dwInputStreamIndex:
//          Zero-based index of an input stream on the DMO.
//
//      pdwFlags:
//          [out] Pointer to a variable that receives a bitwise combination of
//          zero or more DMO_INPUT_STREAM_INFO_FLAGS flags.
//
//  Return Value
//      S_OK Success
//      DMO_E_INVALIDSTREAMINDEX Invalid stream index
//      E_POINTER NULL pointer argument
//
//  The DMO_INPUT_STREAMF_HOLDS_BUFFERS flag indicates that the DMO performs
//  lookahead on the incoming data.
//
//  The application must be sure to allocate sufficient buffers for the DMO
//  to process the input. Call the GetInputSizeInfo method to determine the
//  buffer requirements.
//
HRESULT CVideoDMO::InternalGetInputStreamInfo(DWORD dwInputStreamIndex, DWORD *pdwFlags)
{
    if(pdwFlags == NULL)
    {
        return E_POINTER;
    }
    *pdwFlags = DMO_INPUT_STREAMF_WHOLE_SAMPLES;
    *pdwFlags |= DMO_INPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER;
    *pdwFlags |= DMO_INPUT_STREAMF_FIXED_SAMPLE_SIZE;
    if(m_NumFieldsToBuffer > 1)
    {
        *pdwFlags |= DMO_INPUT_STREAMF_HOLDS_BUFFERS;
    }
    return S_OK;
}


//////////////////////////////////////////
//
//  IMediaObjectImpl::InternalGetOutputStreamInfo
//
//  *** Called by GetOutputStreamInfo, description below ***
//
//  The GetOutputStreamInfo method retrieves information about an output
//  stream; for example, whether the stream is discardable, and whether
//  it uses a fixed sample size. This information never changes.
//
//  Parameters
//      dwOutputStreamIndex
//          Zero-based index of an output stream on the DMO.
//
//      pdwFlags
//          [out] Pointer to a variable that receives a bitwise combination
//          of zero or more DMO_OUTPUT_STREAM_INFO_FLAGS flags.
//
//  Return Value
//
//      S_OK Success
//      DMO_E_INVALIDSTREAMINDEX Invalid stream index
//      E_POINTER NULL pointer argument
//
HRESULT CVideoDMO::InternalGetOutputStreamInfo(DWORD dwOutputStreamIndex, DWORD *pdwFlags)
{
    if(pdwFlags == NULL)
    {
        return E_POINTER;
    }
    *pdwFlags = DMO_OUTPUT_STREAMF_WHOLE_SAMPLES;
    *pdwFlags |= DMO_OUTPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER;
    *pdwFlags |= DMO_OUTPUT_STREAMF_FIXED_SAMPLE_SIZE;
    *pdwFlags |= DMO_OUTPUT_STREAMF_DISCARDABLE;
    return S_OK;
}

void CVideoDMO::RemoveOneFieldFromBuffer()
{
    ASSERT(m_FieldsInBuffer > 0);
    m_IncomingFields[m_FieldsInBuffer - 1].Clear();
    --m_FieldsInBuffer;
}


STDMETHODIMP CVideoDMO::PushSample(IMediaSample* InputSample)
{
    // should never be called
    ASSERT(FALSE);
    return S_OK;
}

STDMETHODIMP CVideoDMO::get_NumFields(DWORD* Count)
{
    *Count = m_FieldsInBuffer;
    return S_OK;
}

STDMETHODIMP CVideoDMO::GetField(DWORD Index, IInterlacedField** Field)
{
    if(*Field != NULL)
    {
        (*Field)->Release();
    }
    if(Index < m_FieldsInBuffer)
    {
        *Field = &(m_IncomingFields[m_FieldsInBuffer - Index - 1]);
        (*Field)->AddRef();
    }
    else
    {
        *Field = NULL;
    }
    return S_OK;
}


STDMETHODIMP CVideoDMO::GetMovementMap(IMediaBuffer** MovementMap)
{
    return E_NOTIMPL;
}


STDMETHODIMP CVideoDMO::PopStack()
{
    RemoveOneFieldFromBuffer();
    return S_OK;
}

STDMETHODIMP CVideoDMO::ClearAll()
{
    InternalFlush();
    return S_OK;
}

CVideoDMO::CField::CField()
{
    static DWORD FieldNumber = 0;
    m_FieldNumber = FieldNumber++;
}


STDMETHODIMP CVideoDMO::CField::GetBufferAndLength(BYTE** ppBuffer, DWORD* pcbLength)
{
    return m_Buffer->GetBufferAndLength(ppBuffer, pcbLength);
}

STDMETHODIMP CVideoDMO::CField::GetMaxLength(DWORD* pcbMaxLength)
{
    return m_Buffer->GetMaxLength(pcbMaxLength);
}

STDMETHODIMP CVideoDMO::CField::SetLength(DWORD cbLength)
{
    return m_Buffer->SetLength(cbLength);
}

STDMETHODIMP CVideoDMO::CField::get_TopFieldFirst(BOOLEAN* TopFieldFirst)
{
    if(m_IsTopLine)
    {
        *TopFieldFirst = TRUE;
    }
    else
    {
        *TopFieldFirst = FALSE;
    }
    return S_OK;
}

STDMETHODIMP CVideoDMO::CField::get_Hint(eDetectionHint* HintValue)
{
    *HintValue = m_Hint;
    return S_OK;
}

STDMETHODIMP CVideoDMO::CField::get_FieldNumber(DWORD* FieldNumber)
{
    *FieldNumber = m_FieldNumber;
    return S_OK;
}

