////////////////////////////////////////////////////////////////////////////
// $Id: CInPlaceDMO.h,v 1.2 2003-05-21 17:05:59 adcockj Exp $
/////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 John Adcock.  All rights reserved.
// This software was based on sample code generated by the 
// DMO project wizard.  That code is (c) Microsoft Corporation
/////////////////////////////////////////////////////////////////////////////
//
// This file is free software; you can redistribute it and/or modify it
// under the terms of the GNU Library General Public License as published by
// the Free Software Foundation; either version 2 of the License, or (at your
// option) any later version.
//
// This software is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Library General Public License for more details
//
/////////////////////////////////////////////////////////////////////////////
// CVS Log
//
// $Log: not supported by cvs2svn $
// Revision 1.1  2003/05/16 16:19:12  adcockj
// Added new files into DMO framework
//
/////////////////////////////////////////////////////////////////////////////

#pragma once 

#include "CDMO.h"


/////////////////////////////////////////////////////////////////////////////
// CInPlaceDMO
class ATL_NO_VTABLE CSimpleInPlaceVideoDMO : 
    public CDMO,
	public IMediaObjectInPlace,
    IDScalerVideoFilterPlugin
{
public:
    CSimpleInPlaceVideoDMO(eVideoFilterPosition Position);
	virtual ~CSimpleInPlaceVideoDMO();

BEGIN_COM_MAP(CSimpleInPlaceVideoDMO)
	COM_INTERFACE_ENTRY(IMediaObjectInPlace)
    COM_INTERFACE_ENTRY(IDScalerVideoFilterPlugin)
    COM_INTERFACE_ENTRY_CHAIN(CDMO)
END_COM_MAP()

public:
	// IMediaObjectInPlace Methods
	STDMETHOD(Process)(ULONG ulSize, BYTE *pData, REFERENCE_TIME refTimeStart,DWORD dwFlags);
	STDMETHOD(Clone)(IMediaObjectInPlace **ppMediaObject);
	STDMETHOD(GetLatency)(REFERENCE_TIME *pLatencyTime);

	//IMediaObjectImpl Methods   
	STDMETHOD(InternalProcessInput)(DWORD dwInputStreamIndex, IMediaBuffer *pBuffer, DWORD dwFlags, REFERENCE_TIME rtTimestamp, REFERENCE_TIME rtTimelength);
	STDMETHOD(InternalProcessOutput)(DWORD dwFlags, DWORD cOutputBufferCount, DMO_OUTPUT_DATA_BUFFER *pOutputBuffers, DWORD *pdwStatus);
    HRESULT InternalGetInputType(DWORD dwInputStreamIndex, DWORD dwTypeIndex, DMO_MEDIA_TYPE *pmt);
	HRESULT InternalGetOutputType(DWORD dwOutputStreamIndex, DWORD dwTypeIndex, DMO_MEDIA_TYPE *pmt);
    HRESULT InternalCheckInputType(DWORD dwInputStreamIndex, const DMO_MEDIA_TYPE *pmt);
    HRESULT InternalCheckOutputType(DWORD dwInputStreamIndex, const DMO_MEDIA_TYPE *pmt);
	STDMETHOD(InternalDiscontinuity)(DWORD dwInputStreamIndex);
    STDMETHOD(InternalFlush)(void);
	STDMETHOD(InternalFreeStreamingResources)(void);
    STDMETHOD(InternalGetInputSizeInfo)(DWORD dwInputStreamIndex, DWORD *pcbSize, DWORD *pcbMaxLookahead, DWORD *pcbAlignment);
	STDMETHOD(InternalGetOutputSizeInfo)(DWORD dwOutputStreamIndex, DWORD *pcbSize, DWORD *pcbAlignment);
    STDMETHOD(InternalGetInputStreamInfo)(DWORD dwInputStreamIndex, DWORD *pdwFlags);
    STDMETHOD(InternalGetOutputStreamInfo)(DWORD dwInputStreamIndex, DWORD *pdwFlags);
	STDMETHOD(InternalAcceptingInput)(DWORD dwInputStreamIndex);

    // IDScalerVideoFilterPlugin
    STDMETHOD(get_Position)(eVideoFilterPosition* pPosition);
    STDMETHOD(get_NumFieldsDelay)(long* pFieldsDelay);
    STDMETHOD(get_NumFieldsBuffered)(long* pFieldsBuffered);

protected:
    virtual void DoProcess(DMO_OUTPUT_DATA_BUFFER *pOutputBuffer);
    virtual void DoProcessOnLineYUY2(const BYTE* pInput, BYTE* pOutput, int Bytes);
    virtual void DoProcessOnLumaLine(const BYTE* pInput, BYTE* pOutput, int Bytes);
    virtual void DoProcessOnUVLine(const BYTE* pInput, BYTE* pOutput, int Bytes);
    virtual void DoProcessOnULine(const BYTE* pInput, BYTE* pOutput, int Bytes);
    virtual void DoProcessOnVLine(const BYTE* pInput, BYTE* pOutput, int Bytes);
    virtual void DoInPlaceProcessOnLineYUY2(BYTE* pData, int Bytes);
    virtual void DoInPlaceProcessOnLumaLine(BYTE* pData, int Bytes);
    virtual void DoInPlaceProcessOnUVLine(BYTE* pData, int Bytes);
    virtual void DoInPlaceProcessOnULine(BYTE* pData, int Bytes);
    virtual void DoInPlaceProcessOnVLine(BYTE* pData, int Bytes);
protected:
    CComPtr<IMediaBuffer> m_Buffer;
    eVideoFilterPosition m_Position;
    BOOL m_bValidTime;
    REFERENCE_TIME m_StartTime;
    REFERENCE_TIME m_Length;
};

template<class T> void Clone( T* ObjToBeCloned, IMediaObjectInPlace **ppMediaObject)
{
	// Check the input pointer
	if (!ppMediaObject)
	{
		return E_POINTER;
	}

    // This will be cleaned up when client releases the newly created object
    // or if there's some error along the way
	T * pNewInPlace = new CComObject<T>;
	if( !pNewInPlace )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_OK;

	hr = pNewInPlace->UpdateStatesInternal();

	IMediaObject* pCloned = NULL;
	if(SUCCEEDED(hr))
	{
		IUnknown *pUnk;
		hr = pNewInPlace->QueryInterface( IID_IUnknown, (void **) &pUnk );
		if( SUCCEEDED( hr ) )
		{
			hr = pUnk->QueryInterface( IID_IMediaObject, (void **) &pCloned );
			pUnk->Release();
		}
	}

	// Copy parameter control information
    // \todo make sure this function also copies the values
	if (SUCCEEDED(hr))
	{
		hr = pNewInPlace->CopyParamsFromSource((CParamsManager *)ObjToBeCloned);
	}


	// Copy the input and output types
	if (SUCCEEDED(hr))
	{
		DMO_MEDIA_TYPE mt;
		DWORD cInputStreams = 0;
		DWORD cOutputStreams = 0;
		ObjToBeCloned->GetStreamCount(&cInputStreams, &cOutputStreams);

		for (DWORD i = 0; i < ObjToBeCloned->cInputStreams && SUCCEEDED(hr); ++i)
		{
			hr = ObjToBeCloned->GetInputCurrentType(i, &mt);
			if (hr == DMO_E_TYPE_NOT_SET)
			{
				hr = S_OK; // great, don't need to set the cloned DMO
			}
			else if (SUCCEEDED(hr))
			{
				hr = pCloned->SetInputType(i, &mt, 0);
				MoFreeMediaType( &mt );
			}
		}

		for (i = 0; i < ObjToBeCloned->cOutputStreams && SUCCEEDED(hr); ++i)
		{
			hr = ObjToBeCloned->GetOutputCurrentType(i, &mt);
			if (hr == DMO_E_TYPE_NOT_SET)
			{
				hr = S_OK; // great, don't need to set the cloned DMO
			}
			else if (SUCCEEDED(hr))
			{
				hr = pCloned->SetOutputType(i, &mt, 0);
				MoFreeMediaType( &mt );
			}
		}

		if (SUCCEEDED(hr))
		{
			hr = pCloned->QueryInterface(IID_IMediaObjectInPlace, (void**)ppMediaObject);
		}

		// Release the object's original ref.  If clone succeeded (made it through QI) then returned pointer
		// has one ref.  If we failed, refs drop to zero, freeing the object.
		pCloned->Release();
	}

    // Something went wrong, clean up for client
    if (FAILED(hr))
    {
        delete pNewInPlace;
    }

	return hr;
}

